//
// Copyright (c) 2015 Kamil Baczkowicz
//
// CSOFF: a.*
// This file was generated by the JavaTM Architecture for XML Binding(JAXB) Reference Implementation, v2.2.11 
// See <a href="http://java.sun.com/xml/jaxb">http://java.sun.com/xml/jaxb</a> 
// Any modifications to this file will be lost upon recompilation of the source schema. 
// Timestamp removed by maven-replacer-plugin to avoid detecting changes - see the project POM for details
//


package pl.baczkowicz.mqttspy.configuration.generated;

import java.util.ArrayList;
import java.util.List;
import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlElement;
import javax.xml.bind.annotation.XmlIDREF;
import javax.xml.bind.annotation.XmlSchemaType;
import javax.xml.bind.annotation.XmlType;
import org.jvnet.jaxb2_commons.lang.CopyStrategy;
import org.jvnet.jaxb2_commons.lang.CopyTo;
import org.jvnet.jaxb2_commons.lang.Equals;
import org.jvnet.jaxb2_commons.lang.EqualsStrategy;
import org.jvnet.jaxb2_commons.lang.HashCode;
import org.jvnet.jaxb2_commons.lang.HashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBCopyStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBEqualsStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBHashCodeStrategy;
import org.jvnet.jaxb2_commons.lang.JAXBToStringStrategy;
import org.jvnet.jaxb2_commons.lang.ToString;
import org.jvnet.jaxb2_commons.lang.ToStringStrategy;
import org.jvnet.jaxb2_commons.locator.ObjectLocator;
import org.jvnet.jaxb2_commons.locator.util.LocatorUtils;
import pl.baczkowicz.mqttspy.common.generated.ConnectionDetails;
import pl.baczkowicz.mqttspy.common.generated.PublicationDetails;


/**
 * <p>Java class for UserInterfaceMqttConnectionDetailsV010 complex type.
 * 
 * <p>The following schema fragment specifies the expected content contained within this class.
 * 
 * <pre>
 * &lt;complexType name="UserInterfaceMqttConnectionDetailsV010"&gt;
 *   &lt;complexContent&gt;
 *     &lt;extension base="{http://baczkowicz.pl/mqtt-spy/common}ConnectionDetails"&gt;
 *       &lt;sequence&gt;
 *         &lt;element name="ServerURI" type="{http://www.w3.org/2001/XMLSchema}string"/&gt;
 *         &lt;element name="ClientID" type="{http://www.w3.org/2001/XMLSchema}string"/&gt;
 *         &lt;element name="UserAuthentication" type="{http://baczkowicz.pl/mqtt-spy-configuration}UserAuthentication" minOccurs="0"/&gt;
 *         &lt;element name="LastWillAndTestament" type="{http://baczkowicz.pl/mqtt-spy-configuration}BaseMqttMessage" minOccurs="0"/&gt;
 *         &lt;element name="AutoOpen" type="{http://www.w3.org/2001/XMLSchema}boolean" minOccurs="0"/&gt;
 *         &lt;element name="AutoConnect" type="{http://www.w3.org/2001/XMLSchema}boolean" minOccurs="0"/&gt;
 *         &lt;element name="CleanSession" type="{http://www.w3.org/2001/XMLSchema}boolean" minOccurs="0"/&gt;
 *         &lt;element name="ConnectionTimeout" type="{http://www.w3.org/2001/XMLSchema}int" minOccurs="0"/&gt;
 *         &lt;element name="KeepAliveInterval" type="{http://www.w3.org/2001/XMLSchema}int" minOccurs="0"/&gt;
 *         &lt;element name="Formatter" type="{http://www.w3.org/2001/XMLSchema}IDREF" minOccurs="0"/&gt;
 *         &lt;element name="MinMessagesStoredPerTopic" type="{http://www.w3.org/2001/XMLSchema}int" minOccurs="0"/&gt;
 *         &lt;element name="MaxMessagesStored" type="{http://www.w3.org/2001/XMLSchema}int" minOccurs="0"/&gt;
 *         &lt;element name="PublicationScripts" type="{http://www.w3.org/2001/XMLSchema}string" minOccurs="0"/&gt;
 *         &lt;element name="Publication" type="{http://baczkowicz.pl/mqtt-spy/common}PublicationDetails" maxOccurs="unbounded" minOccurs="0"/&gt;
 *         &lt;element name="Subscription" type="{http://baczkowicz.pl/mqtt-spy-configuration}TabbedSubscriptionDetails" maxOccurs="unbounded" minOccurs="0"/&gt;
 *       &lt;/sequence&gt;
 *     &lt;/extension&gt;
 *   &lt;/complexContent&gt;
 * &lt;/complexType&gt;
 * </pre>
 * 
 * 
*/
@SuppressWarnings("all")
@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = "UserInterfaceMqttConnectionDetailsV010", propOrder = {
    "serverURI",
    "clientID",
    "userAuthentication",
    "lastWillAndTestament",
    "autoOpen",
    "autoConnect",
    "cleanSession",
    "connectionTimeout",
    "keepAliveInterval",
    "formatter",
    "minMessagesStoredPerTopic",
    "maxMessagesStored",
    "publicationScripts",
    "publication",
    "subscription"
})
public class UserInterfaceMqttConnectionDetailsV010
    extends ConnectionDetails
    implements Cloneable, CopyTo, Equals, HashCode, ToString
{

    @XmlElement(name = "ServerURI", required = true)
    protected String serverURI;
    @XmlElement(name = "ClientID", required = true)
    protected String clientID;
    @XmlElement(name = "UserAuthentication")
    protected UserAuthentication userAuthentication;
    @XmlElement(name = "LastWillAndTestament")
    protected BaseMqttMessage lastWillAndTestament;
    @XmlElement(name = "AutoOpen", defaultValue = "true")
    protected Boolean autoOpen;
    @XmlElement(name = "AutoConnect", defaultValue = "false")
    protected Boolean autoConnect;
    @XmlElement(name = "CleanSession")
    protected Boolean cleanSession;
    @XmlElement(name = "ConnectionTimeout")
    protected Integer connectionTimeout;
    @XmlElement(name = "KeepAliveInterval")
    protected Integer keepAliveInterval;
    @XmlElement(name = "Formatter")
    @XmlIDREF
    @XmlSchemaType(name = "IDREF")
    protected Object formatter;
    @XmlElement(name = "MinMessagesStoredPerTopic")
    protected Integer minMessagesStoredPerTopic;
    @XmlElement(name = "MaxMessagesStored")
    protected Integer maxMessagesStored;
    @XmlElement(name = "PublicationScripts")
    protected String publicationScripts;
    @XmlElement(name = "Publication")
    protected List<PublicationDetails> publication;
    @XmlElement(name = "Subscription")
    protected List<TabbedSubscriptionDetails> subscription;

    /**
     * Default no-arg constructor
     * 
     */
    public UserInterfaceMqttConnectionDetailsV010() {
        super();
    }

    /**
     * Fully-initialising value constructor
     * 
     */
    public UserInterfaceMqttConnectionDetailsV010(final String serverURI, final String clientID, final UserAuthentication userAuthentication, final BaseMqttMessage lastWillAndTestament, final Boolean autoOpen, final Boolean autoConnect, final Boolean cleanSession, final Integer connectionTimeout, final Integer keepAliveInterval, final Object formatter, final Integer minMessagesStoredPerTopic, final Integer maxMessagesStored, final String publicationScripts, final List<PublicationDetails> publication, final List<TabbedSubscriptionDetails> subscription) {
        this.serverURI = serverURI;
        this.clientID = clientID;
        this.userAuthentication = userAuthentication;
        this.lastWillAndTestament = lastWillAndTestament;
        this.autoOpen = autoOpen;
        this.autoConnect = autoConnect;
        this.cleanSession = cleanSession;
        this.connectionTimeout = connectionTimeout;
        this.keepAliveInterval = keepAliveInterval;
        this.formatter = formatter;
        this.minMessagesStoredPerTopic = minMessagesStoredPerTopic;
        this.maxMessagesStored = maxMessagesStored;
        this.publicationScripts = publicationScripts;
        this.publication = publication;
        this.subscription = subscription;
    }

    /**
     * Gets the value of the serverURI property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getServerURI() {
        return serverURI;
    }

    /**
     * Sets the value of the serverURI property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setServerURI(String value) {
        this.serverURI = value;
    }

    /**
     * Gets the value of the clientID property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getClientID() {
        return clientID;
    }

    /**
     * Sets the value of the clientID property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setClientID(String value) {
        this.clientID = value;
    }

    /**
     * Gets the value of the userAuthentication property.
     * 
     * @return
     *     possible object is
     *     {@link UserAuthentication }
     *     
     */
    public UserAuthentication getUserAuthentication() {
        return userAuthentication;
    }

    /**
     * Sets the value of the userAuthentication property.
     * 
     * @param value
     *     allowed object is
     *     {@link UserAuthentication }
     *     
     */
    public void setUserAuthentication(UserAuthentication value) {
        this.userAuthentication = value;
    }

    /**
     * Gets the value of the lastWillAndTestament property.
     * 
     * @return
     *     possible object is
     *     {@link BaseMqttMessage }
     *     
     */
    public BaseMqttMessage getLastWillAndTestament() {
        return lastWillAndTestament;
    }

    /**
     * Sets the value of the lastWillAndTestament property.
     * 
     * @param value
     *     allowed object is
     *     {@link BaseMqttMessage }
     *     
     */
    public void setLastWillAndTestament(BaseMqttMessage value) {
        this.lastWillAndTestament = value;
    }

    /**
     * Gets the value of the autoOpen property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isAutoOpen() {
        return autoOpen;
    }

    /**
     * Sets the value of the autoOpen property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setAutoOpen(Boolean value) {
        this.autoOpen = value;
    }

    /**
     * Gets the value of the autoConnect property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isAutoConnect() {
        return autoConnect;
    }

    /**
     * Sets the value of the autoConnect property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setAutoConnect(Boolean value) {
        this.autoConnect = value;
    }

    /**
     * Gets the value of the cleanSession property.
     * 
     * @return
     *     possible object is
     *     {@link Boolean }
     *     
     */
    public Boolean isCleanSession() {
        return cleanSession;
    }

    /**
     * Sets the value of the cleanSession property.
     * 
     * @param value
     *     allowed object is
     *     {@link Boolean }
     *     
     */
    public void setCleanSession(Boolean value) {
        this.cleanSession = value;
    }

    /**
     * Gets the value of the connectionTimeout property.
     * 
     * @return
     *     possible object is
     *     {@link Integer }
     *     
     */
    public Integer getConnectionTimeout() {
        return connectionTimeout;
    }

    /**
     * Sets the value of the connectionTimeout property.
     * 
     * @param value
     *     allowed object is
     *     {@link Integer }
     *     
     */
    public void setConnectionTimeout(Integer value) {
        this.connectionTimeout = value;
    }

    /**
     * Gets the value of the keepAliveInterval property.
     * 
     * @return
     *     possible object is
     *     {@link Integer }
     *     
     */
    public Integer getKeepAliveInterval() {
        return keepAliveInterval;
    }

    /**
     * Sets the value of the keepAliveInterval property.
     * 
     * @param value
     *     allowed object is
     *     {@link Integer }
     *     
     */
    public void setKeepAliveInterval(Integer value) {
        this.keepAliveInterval = value;
    }

    /**
     * Gets the value of the formatter property.
     * 
     * @return
     *     possible object is
     *     {@link Object }
     *     
     */
    public Object getFormatter() {
        return formatter;
    }

    /**
     * Sets the value of the formatter property.
     * 
     * @param value
     *     allowed object is
     *     {@link Object }
     *     
     */
    public void setFormatter(Object value) {
        this.formatter = value;
    }

    /**
     * Gets the value of the minMessagesStoredPerTopic property.
     * 
     * @return
     *     possible object is
     *     {@link Integer }
     *     
     */
    public Integer getMinMessagesStoredPerTopic() {
        return minMessagesStoredPerTopic;
    }

    /**
     * Sets the value of the minMessagesStoredPerTopic property.
     * 
     * @param value
     *     allowed object is
     *     {@link Integer }
     *     
     */
    public void setMinMessagesStoredPerTopic(Integer value) {
        this.minMessagesStoredPerTopic = value;
    }

    /**
     * Gets the value of the maxMessagesStored property.
     * 
     * @return
     *     possible object is
     *     {@link Integer }
     *     
     */
    public Integer getMaxMessagesStored() {
        return maxMessagesStored;
    }

    /**
     * Sets the value of the maxMessagesStored property.
     * 
     * @param value
     *     allowed object is
     *     {@link Integer }
     *     
     */
    public void setMaxMessagesStored(Integer value) {
        this.maxMessagesStored = value;
    }

    /**
     * Gets the value of the publicationScripts property.
     * 
     * @return
     *     possible object is
     *     {@link String }
     *     
     */
    public String getPublicationScripts() {
        return publicationScripts;
    }

    /**
     * Sets the value of the publicationScripts property.
     * 
     * @param value
     *     allowed object is
     *     {@link String }
     *     
     */
    public void setPublicationScripts(String value) {
        this.publicationScripts = value;
    }

    /**
     * Gets the value of the publication property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the publication property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPublication().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link PublicationDetails }
     * 
     * 
     */
    public List<PublicationDetails> getPublication() {
        if (publication == null) {
            publication = new ArrayList<PublicationDetails>();
        }
        return this.publication;
    }

    /**
     * Gets the value of the subscription property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the subscription property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getSubscription().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link TabbedSubscriptionDetails }
     * 
     * 
     */
    public List<TabbedSubscriptionDetails> getSubscription() {
        if (subscription == null) {
            subscription = new ArrayList<TabbedSubscriptionDetails>();
        }
        return this.subscription;
    }

    public String toString() {
        final ToStringStrategy strategy = JAXBToStringStrategy.INSTANCE;
        final StringBuilder buffer = new StringBuilder();
        append(null, buffer, strategy);
        return buffer.toString();
    }

    public StringBuilder append(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        strategy.appendStart(locator, this, buffer);
        appendFields(locator, buffer, strategy);
        strategy.appendEnd(locator, this, buffer);
        return buffer;
    }

    public StringBuilder appendFields(ObjectLocator locator, StringBuilder buffer, ToStringStrategy strategy) {
        super.appendFields(locator, buffer, strategy);
        {
            String theServerURI;
            theServerURI = this.getServerURI();
            strategy.appendField(locator, this, "serverURI", buffer, theServerURI);
        }
        {
            String theClientID;
            theClientID = this.getClientID();
            strategy.appendField(locator, this, "clientID", buffer, theClientID);
        }
        {
            UserAuthentication theUserAuthentication;
            theUserAuthentication = this.getUserAuthentication();
            strategy.appendField(locator, this, "userAuthentication", buffer, theUserAuthentication);
        }
        {
            BaseMqttMessage theLastWillAndTestament;
            theLastWillAndTestament = this.getLastWillAndTestament();
            strategy.appendField(locator, this, "lastWillAndTestament", buffer, theLastWillAndTestament);
        }
        {
            Boolean theAutoOpen;
            theAutoOpen = this.isAutoOpen();
            strategy.appendField(locator, this, "autoOpen", buffer, theAutoOpen);
        }
        {
            Boolean theAutoConnect;
            theAutoConnect = this.isAutoConnect();
            strategy.appendField(locator, this, "autoConnect", buffer, theAutoConnect);
        }
        {
            Boolean theCleanSession;
            theCleanSession = this.isCleanSession();
            strategy.appendField(locator, this, "cleanSession", buffer, theCleanSession);
        }
        {
            Integer theConnectionTimeout;
            theConnectionTimeout = this.getConnectionTimeout();
            strategy.appendField(locator, this, "connectionTimeout", buffer, theConnectionTimeout);
        }
        {
            Integer theKeepAliveInterval;
            theKeepAliveInterval = this.getKeepAliveInterval();
            strategy.appendField(locator, this, "keepAliveInterval", buffer, theKeepAliveInterval);
        }
        {
            Object theFormatter;
            theFormatter = this.getFormatter();
            strategy.appendField(locator, this, "formatter", buffer, theFormatter);
        }
        {
            Integer theMinMessagesStoredPerTopic;
            theMinMessagesStoredPerTopic = this.getMinMessagesStoredPerTopic();
            strategy.appendField(locator, this, "minMessagesStoredPerTopic", buffer, theMinMessagesStoredPerTopic);
        }
        {
            Integer theMaxMessagesStored;
            theMaxMessagesStored = this.getMaxMessagesStored();
            strategy.appendField(locator, this, "maxMessagesStored", buffer, theMaxMessagesStored);
        }
        {
            String thePublicationScripts;
            thePublicationScripts = this.getPublicationScripts();
            strategy.appendField(locator, this, "publicationScripts", buffer, thePublicationScripts);
        }
        {
            List<PublicationDetails> thePublication;
            thePublication = (((this.publication!= null)&&(!this.publication.isEmpty()))?this.getPublication():null);
            strategy.appendField(locator, this, "publication", buffer, thePublication);
        }
        {
            List<TabbedSubscriptionDetails> theSubscription;
            theSubscription = (((this.subscription!= null)&&(!this.subscription.isEmpty()))?this.getSubscription():null);
            strategy.appendField(locator, this, "subscription", buffer, theSubscription);
        }
        return buffer;
    }

    public boolean equals(ObjectLocator thisLocator, ObjectLocator thatLocator, Object object, EqualsStrategy strategy) {
        if (!(object instanceof UserInterfaceMqttConnectionDetailsV010)) {
            return false;
        }
        if (this == object) {
            return true;
        }
        if (!super.equals(thisLocator, thatLocator, object, strategy)) {
            return false;
        }
        final UserInterfaceMqttConnectionDetailsV010 that = ((UserInterfaceMqttConnectionDetailsV010) object);
        {
            String lhsServerURI;
            lhsServerURI = this.getServerURI();
            String rhsServerURI;
            rhsServerURI = that.getServerURI();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "serverURI", lhsServerURI), LocatorUtils.property(thatLocator, "serverURI", rhsServerURI), lhsServerURI, rhsServerURI)) {
                return false;
            }
        }
        {
            String lhsClientID;
            lhsClientID = this.getClientID();
            String rhsClientID;
            rhsClientID = that.getClientID();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "clientID", lhsClientID), LocatorUtils.property(thatLocator, "clientID", rhsClientID), lhsClientID, rhsClientID)) {
                return false;
            }
        }
        {
            UserAuthentication lhsUserAuthentication;
            lhsUserAuthentication = this.getUserAuthentication();
            UserAuthentication rhsUserAuthentication;
            rhsUserAuthentication = that.getUserAuthentication();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "userAuthentication", lhsUserAuthentication), LocatorUtils.property(thatLocator, "userAuthentication", rhsUserAuthentication), lhsUserAuthentication, rhsUserAuthentication)) {
                return false;
            }
        }
        {
            BaseMqttMessage lhsLastWillAndTestament;
            lhsLastWillAndTestament = this.getLastWillAndTestament();
            BaseMqttMessage rhsLastWillAndTestament;
            rhsLastWillAndTestament = that.getLastWillAndTestament();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "lastWillAndTestament", lhsLastWillAndTestament), LocatorUtils.property(thatLocator, "lastWillAndTestament", rhsLastWillAndTestament), lhsLastWillAndTestament, rhsLastWillAndTestament)) {
                return false;
            }
        }
        {
            Boolean lhsAutoOpen;
            lhsAutoOpen = this.isAutoOpen();
            Boolean rhsAutoOpen;
            rhsAutoOpen = that.isAutoOpen();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "autoOpen", lhsAutoOpen), LocatorUtils.property(thatLocator, "autoOpen", rhsAutoOpen), lhsAutoOpen, rhsAutoOpen)) {
                return false;
            }
        }
        {
            Boolean lhsAutoConnect;
            lhsAutoConnect = this.isAutoConnect();
            Boolean rhsAutoConnect;
            rhsAutoConnect = that.isAutoConnect();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "autoConnect", lhsAutoConnect), LocatorUtils.property(thatLocator, "autoConnect", rhsAutoConnect), lhsAutoConnect, rhsAutoConnect)) {
                return false;
            }
        }
        {
            Boolean lhsCleanSession;
            lhsCleanSession = this.isCleanSession();
            Boolean rhsCleanSession;
            rhsCleanSession = that.isCleanSession();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "cleanSession", lhsCleanSession), LocatorUtils.property(thatLocator, "cleanSession", rhsCleanSession), lhsCleanSession, rhsCleanSession)) {
                return false;
            }
        }
        {
            Integer lhsConnectionTimeout;
            lhsConnectionTimeout = this.getConnectionTimeout();
            Integer rhsConnectionTimeout;
            rhsConnectionTimeout = that.getConnectionTimeout();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "connectionTimeout", lhsConnectionTimeout), LocatorUtils.property(thatLocator, "connectionTimeout", rhsConnectionTimeout), lhsConnectionTimeout, rhsConnectionTimeout)) {
                return false;
            }
        }
        {
            Integer lhsKeepAliveInterval;
            lhsKeepAliveInterval = this.getKeepAliveInterval();
            Integer rhsKeepAliveInterval;
            rhsKeepAliveInterval = that.getKeepAliveInterval();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "keepAliveInterval", lhsKeepAliveInterval), LocatorUtils.property(thatLocator, "keepAliveInterval", rhsKeepAliveInterval), lhsKeepAliveInterval, rhsKeepAliveInterval)) {
                return false;
            }
        }
        {
            Object lhsFormatter;
            lhsFormatter = this.getFormatter();
            Object rhsFormatter;
            rhsFormatter = that.getFormatter();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "formatter", lhsFormatter), LocatorUtils.property(thatLocator, "formatter", rhsFormatter), lhsFormatter, rhsFormatter)) {
                return false;
            }
        }
        {
            Integer lhsMinMessagesStoredPerTopic;
            lhsMinMessagesStoredPerTopic = this.getMinMessagesStoredPerTopic();
            Integer rhsMinMessagesStoredPerTopic;
            rhsMinMessagesStoredPerTopic = that.getMinMessagesStoredPerTopic();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "minMessagesStoredPerTopic", lhsMinMessagesStoredPerTopic), LocatorUtils.property(thatLocator, "minMessagesStoredPerTopic", rhsMinMessagesStoredPerTopic), lhsMinMessagesStoredPerTopic, rhsMinMessagesStoredPerTopic)) {
                return false;
            }
        }
        {
            Integer lhsMaxMessagesStored;
            lhsMaxMessagesStored = this.getMaxMessagesStored();
            Integer rhsMaxMessagesStored;
            rhsMaxMessagesStored = that.getMaxMessagesStored();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "maxMessagesStored", lhsMaxMessagesStored), LocatorUtils.property(thatLocator, "maxMessagesStored", rhsMaxMessagesStored), lhsMaxMessagesStored, rhsMaxMessagesStored)) {
                return false;
            }
        }
        {
            String lhsPublicationScripts;
            lhsPublicationScripts = this.getPublicationScripts();
            String rhsPublicationScripts;
            rhsPublicationScripts = that.getPublicationScripts();
            if (!strategy.equals(LocatorUtils.property(thisLocator, "publicationScripts", lhsPublicationScripts), LocatorUtils.property(thatLocator, "publicationScripts", rhsPublicationScripts), lhsPublicationScripts, rhsPublicationScripts)) {
                return false;
            }
        }
        {
            List<PublicationDetails> lhsPublication;
            lhsPublication = (((this.publication!= null)&&(!this.publication.isEmpty()))?this.getPublication():null);
            List<PublicationDetails> rhsPublication;
            rhsPublication = (((that.publication!= null)&&(!that.publication.isEmpty()))?that.getPublication():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "publication", lhsPublication), LocatorUtils.property(thatLocator, "publication", rhsPublication), lhsPublication, rhsPublication)) {
                return false;
            }
        }
        {
            List<TabbedSubscriptionDetails> lhsSubscription;
            lhsSubscription = (((this.subscription!= null)&&(!this.subscription.isEmpty()))?this.getSubscription():null);
            List<TabbedSubscriptionDetails> rhsSubscription;
            rhsSubscription = (((that.subscription!= null)&&(!that.subscription.isEmpty()))?that.getSubscription():null);
            if (!strategy.equals(LocatorUtils.property(thisLocator, "subscription", lhsSubscription), LocatorUtils.property(thatLocator, "subscription", rhsSubscription), lhsSubscription, rhsSubscription)) {
                return false;
            }
        }
        return true;
    }

    public boolean equals(Object object) {
        final EqualsStrategy strategy = JAXBEqualsStrategy.INSTANCE;
        return equals(null, null, object, strategy);
    }

    public int hashCode(ObjectLocator locator, HashCodeStrategy strategy) {
        int currentHashCode = super.hashCode(locator, strategy);
        {
            String theServerURI;
            theServerURI = this.getServerURI();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "serverURI", theServerURI), currentHashCode, theServerURI);
        }
        {
            String theClientID;
            theClientID = this.getClientID();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "clientID", theClientID), currentHashCode, theClientID);
        }
        {
            UserAuthentication theUserAuthentication;
            theUserAuthentication = this.getUserAuthentication();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "userAuthentication", theUserAuthentication), currentHashCode, theUserAuthentication);
        }
        {
            BaseMqttMessage theLastWillAndTestament;
            theLastWillAndTestament = this.getLastWillAndTestament();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "lastWillAndTestament", theLastWillAndTestament), currentHashCode, theLastWillAndTestament);
        }
        {
            Boolean theAutoOpen;
            theAutoOpen = this.isAutoOpen();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "autoOpen", theAutoOpen), currentHashCode, theAutoOpen);
        }
        {
            Boolean theAutoConnect;
            theAutoConnect = this.isAutoConnect();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "autoConnect", theAutoConnect), currentHashCode, theAutoConnect);
        }
        {
            Boolean theCleanSession;
            theCleanSession = this.isCleanSession();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "cleanSession", theCleanSession), currentHashCode, theCleanSession);
        }
        {
            Integer theConnectionTimeout;
            theConnectionTimeout = this.getConnectionTimeout();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "connectionTimeout", theConnectionTimeout), currentHashCode, theConnectionTimeout);
        }
        {
            Integer theKeepAliveInterval;
            theKeepAliveInterval = this.getKeepAliveInterval();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "keepAliveInterval", theKeepAliveInterval), currentHashCode, theKeepAliveInterval);
        }
        {
            Object theFormatter;
            theFormatter = this.getFormatter();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "formatter", theFormatter), currentHashCode, theFormatter);
        }
        {
            Integer theMinMessagesStoredPerTopic;
            theMinMessagesStoredPerTopic = this.getMinMessagesStoredPerTopic();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "minMessagesStoredPerTopic", theMinMessagesStoredPerTopic), currentHashCode, theMinMessagesStoredPerTopic);
        }
        {
            Integer theMaxMessagesStored;
            theMaxMessagesStored = this.getMaxMessagesStored();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "maxMessagesStored", theMaxMessagesStored), currentHashCode, theMaxMessagesStored);
        }
        {
            String thePublicationScripts;
            thePublicationScripts = this.getPublicationScripts();
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "publicationScripts", thePublicationScripts), currentHashCode, thePublicationScripts);
        }
        {
            List<PublicationDetails> thePublication;
            thePublication = (((this.publication!= null)&&(!this.publication.isEmpty()))?this.getPublication():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "publication", thePublication), currentHashCode, thePublication);
        }
        {
            List<TabbedSubscriptionDetails> theSubscription;
            theSubscription = (((this.subscription!= null)&&(!this.subscription.isEmpty()))?this.getSubscription():null);
            currentHashCode = strategy.hashCode(LocatorUtils.property(locator, "subscription", theSubscription), currentHashCode, theSubscription);
        }
        return currentHashCode;
    }

    public int hashCode() {
        final HashCodeStrategy strategy = JAXBHashCodeStrategy.INSTANCE;
        return this.hashCode(null, strategy);
    }

    public Object clone() {
        return copyTo(createNewInstance());
    }

    public Object copyTo(Object target) {
        final CopyStrategy strategy = JAXBCopyStrategy.INSTANCE;
        return copyTo(null, target, strategy);
    }

    public Object copyTo(ObjectLocator locator, Object target, CopyStrategy strategy) {
        final Object draftCopy = ((target == null)?createNewInstance():target);
        super.copyTo(locator, draftCopy, strategy);
        if (draftCopy instanceof UserInterfaceMqttConnectionDetailsV010) {
            final UserInterfaceMqttConnectionDetailsV010 copy = ((UserInterfaceMqttConnectionDetailsV010) draftCopy);
            if (this.serverURI!= null) {
                String sourceServerURI;
                sourceServerURI = this.getServerURI();
                String copyServerURI = ((String) strategy.copy(LocatorUtils.property(locator, "serverURI", sourceServerURI), sourceServerURI));
                copy.setServerURI(copyServerURI);
            } else {
                copy.serverURI = null;
            }
            if (this.clientID!= null) {
                String sourceClientID;
                sourceClientID = this.getClientID();
                String copyClientID = ((String) strategy.copy(LocatorUtils.property(locator, "clientID", sourceClientID), sourceClientID));
                copy.setClientID(copyClientID);
            } else {
                copy.clientID = null;
            }
            if (this.userAuthentication!= null) {
                UserAuthentication sourceUserAuthentication;
                sourceUserAuthentication = this.getUserAuthentication();
                UserAuthentication copyUserAuthentication = ((UserAuthentication) strategy.copy(LocatorUtils.property(locator, "userAuthentication", sourceUserAuthentication), sourceUserAuthentication));
                copy.setUserAuthentication(copyUserAuthentication);
            } else {
                copy.userAuthentication = null;
            }
            if (this.lastWillAndTestament!= null) {
                BaseMqttMessage sourceLastWillAndTestament;
                sourceLastWillAndTestament = this.getLastWillAndTestament();
                BaseMqttMessage copyLastWillAndTestament = ((BaseMqttMessage) strategy.copy(LocatorUtils.property(locator, "lastWillAndTestament", sourceLastWillAndTestament), sourceLastWillAndTestament));
                copy.setLastWillAndTestament(copyLastWillAndTestament);
            } else {
                copy.lastWillAndTestament = null;
            }
            if (this.autoOpen!= null) {
                Boolean sourceAutoOpen;
                sourceAutoOpen = this.isAutoOpen();
                Boolean copyAutoOpen = ((Boolean) strategy.copy(LocatorUtils.property(locator, "autoOpen", sourceAutoOpen), sourceAutoOpen));
                copy.setAutoOpen(copyAutoOpen);
            } else {
                copy.autoOpen = null;
            }
            if (this.autoConnect!= null) {
                Boolean sourceAutoConnect;
                sourceAutoConnect = this.isAutoConnect();
                Boolean copyAutoConnect = ((Boolean) strategy.copy(LocatorUtils.property(locator, "autoConnect", sourceAutoConnect), sourceAutoConnect));
                copy.setAutoConnect(copyAutoConnect);
            } else {
                copy.autoConnect = null;
            }
            if (this.cleanSession!= null) {
                Boolean sourceCleanSession;
                sourceCleanSession = this.isCleanSession();
                Boolean copyCleanSession = ((Boolean) strategy.copy(LocatorUtils.property(locator, "cleanSession", sourceCleanSession), sourceCleanSession));
                copy.setCleanSession(copyCleanSession);
            } else {
                copy.cleanSession = null;
            }
            if (this.connectionTimeout!= null) {
                Integer sourceConnectionTimeout;
                sourceConnectionTimeout = this.getConnectionTimeout();
                Integer copyConnectionTimeout = ((Integer) strategy.copy(LocatorUtils.property(locator, "connectionTimeout", sourceConnectionTimeout), sourceConnectionTimeout));
                copy.setConnectionTimeout(copyConnectionTimeout);
            } else {
                copy.connectionTimeout = null;
            }
            if (this.keepAliveInterval!= null) {
                Integer sourceKeepAliveInterval;
                sourceKeepAliveInterval = this.getKeepAliveInterval();
                Integer copyKeepAliveInterval = ((Integer) strategy.copy(LocatorUtils.property(locator, "keepAliveInterval", sourceKeepAliveInterval), sourceKeepAliveInterval));
                copy.setKeepAliveInterval(copyKeepAliveInterval);
            } else {
                copy.keepAliveInterval = null;
            }
            if (this.formatter!= null) {
                Object sourceFormatter;
                sourceFormatter = this.getFormatter();
                Object copyFormatter = ((Object) strategy.copy(LocatorUtils.property(locator, "formatter", sourceFormatter), sourceFormatter));
                copy.setFormatter(copyFormatter);
            } else {
                copy.formatter = null;
            }
            if (this.minMessagesStoredPerTopic!= null) {
                Integer sourceMinMessagesStoredPerTopic;
                sourceMinMessagesStoredPerTopic = this.getMinMessagesStoredPerTopic();
                Integer copyMinMessagesStoredPerTopic = ((Integer) strategy.copy(LocatorUtils.property(locator, "minMessagesStoredPerTopic", sourceMinMessagesStoredPerTopic), sourceMinMessagesStoredPerTopic));
                copy.setMinMessagesStoredPerTopic(copyMinMessagesStoredPerTopic);
            } else {
                copy.minMessagesStoredPerTopic = null;
            }
            if (this.maxMessagesStored!= null) {
                Integer sourceMaxMessagesStored;
                sourceMaxMessagesStored = this.getMaxMessagesStored();
                Integer copyMaxMessagesStored = ((Integer) strategy.copy(LocatorUtils.property(locator, "maxMessagesStored", sourceMaxMessagesStored), sourceMaxMessagesStored));
                copy.setMaxMessagesStored(copyMaxMessagesStored);
            } else {
                copy.maxMessagesStored = null;
            }
            if (this.publicationScripts!= null) {
                String sourcePublicationScripts;
                sourcePublicationScripts = this.getPublicationScripts();
                String copyPublicationScripts = ((String) strategy.copy(LocatorUtils.property(locator, "publicationScripts", sourcePublicationScripts), sourcePublicationScripts));
                copy.setPublicationScripts(copyPublicationScripts);
            } else {
                copy.publicationScripts = null;
            }
            if ((this.publication!= null)&&(!this.publication.isEmpty())) {
                List<PublicationDetails> sourcePublication;
                sourcePublication = (((this.publication!= null)&&(!this.publication.isEmpty()))?this.getPublication():null);
                @SuppressWarnings("unchecked")
                List<PublicationDetails> copyPublication = ((List<PublicationDetails> ) strategy.copy(LocatorUtils.property(locator, "publication", sourcePublication), sourcePublication));
                copy.publication = null;
                if (copyPublication!= null) {
                    List<PublicationDetails> uniquePublicationl = copy.getPublication();
                    uniquePublicationl.addAll(copyPublication);
                }
            } else {
                copy.publication = null;
            }
            if ((this.subscription!= null)&&(!this.subscription.isEmpty())) {
                List<TabbedSubscriptionDetails> sourceSubscription;
                sourceSubscription = (((this.subscription!= null)&&(!this.subscription.isEmpty()))?this.getSubscription():null);
                @SuppressWarnings("unchecked")
                List<TabbedSubscriptionDetails> copySubscription = ((List<TabbedSubscriptionDetails> ) strategy.copy(LocatorUtils.property(locator, "subscription", sourceSubscription), sourceSubscription));
                copy.subscription = null;
                if (copySubscription!= null) {
                    List<TabbedSubscriptionDetails> uniqueSubscriptionl = copy.getSubscription();
                    uniqueSubscriptionl.addAll(copySubscription);
                }
            } else {
                copy.subscription = null;
            }
        }
        return draftCopy;
    }

    public Object createNewInstance() {
        return new UserInterfaceMqttConnectionDetailsV010();
    }

}
